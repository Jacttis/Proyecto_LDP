%%% Carga la VT de la clase A
        SetLabel VTA, Libre                                     %Creo la etiqueta para la VT de A
        SetD Libre, initA         @VTA: direccion de initA      %Pongo en la VTA la direccion la version de init que usa A (respetando el offset de met1!)
        SetD Libre+1, m1A       @VTA: direccion de m1A      %Pongo en la VTA la direccion la version de m1 que usa A (respetando el offset de met1!)
        SetD Libre+2, m2A        @VTA: direccion de m2A     %Pongo en la VTA la direccion la version de m2 que usa A(respetando el offset de met1!)
        SetLibre Libre+4                                        %Actualizo Libre segun el tamaño de la VTA
        SetActual Libre                                         %Actualizo actual tambien

%%% Carga la VT de la clase B
        SetLabel VTB, Libre                                  %Creo la etiqueta para la VT de B
        SetD Libre, initB       @VTB:direccion de initB
        SetD Libre+1, m1A       @VTB:direccion de m1A
        SetD libre+2, m2A        @VTB:direccion de m2A
        SetD Libre+3, m2B       @VTB:direccion de m2B
        SetD libre+4, VTA       @VTB:direccion de VTA
        SetLibre Libre+6                                        %Actualizo Libre segun el tamaño de la VTB
        SetActual Libre                                         %Actualizo actual tambien
%%% Carga la VT de la clase C
        SetLabel VTC, Libre                                     %Creo la etiqueta para la VT de C
        SetD Libre, initC         @VTC: direccion de initC      %Pongo en la VTA la direccion la version de init que usa C (respetando el offset de met1!)
        SetD Libre+1, m1C       @VTC: direccion de m1C      %Pongo en la VTA la direccion la version de m1 que usa C (respetando el offset de met1!)
        SetD Libre+2, m2A       @VTC:direccion de m2A
        SetD Libre+3, m2B       @VTC:direccion de m2B
        SetD Libre+4, VTB       @VTC:direccion de VTB
        SetLibre Libre+6                                        %Actualizo Libre segun el tamaño de la VTC
        SetActual Libre                                         %Actualizo actual tambien
%%% Carga la VT de la clase D
        SetLabel VTD, Libre                                     %Creo la etiqueta para la VT de D
        SetD Libre, initC         @VTD: direccion de initC      %Pongo en la VTA la direccion la version de init que usa D (respetando el offset de met1!)
        SetD Libre+1, m1C       @VTD: direccion de m1C      %Pongo en la VTA la direccion la version de m2 que usa D (respetando el offset de met1!)
        SetD Libre+2, m2D       @VTD:direccion de m2D
        SetD Libre+3, m2B       @VTD:direccion de m2B
        SetD Libre+4, initD     @VTD:direccion de initD
        SetD Libre+5, VTC       @VTD:direccion de VTC
        SetLibre Libre+7                                        %Actualizo Libre segun el tamaño de la VTD
        SetActual Libre                                         %Actualizo actual tambien

%%% Carga la VT de la clase Principal
        SetLabel VTPrincipal, Libre                                     %Creo la etiqueta para la VT de D
        SetLibre Libre+1                                        %Actualizo Libre segun el tamaño de la VTD
        SetActual Libre                                         %Actualizo actual tambien


%%%-----------------------------------------------------------------------------

%%%-------------Codigo de Incializacion (Llamada a main)------------------------
%%% Llama a main y finaliza
        SetD Libre, pc+5            @PTR    %Guardo puntero de retorno caigo en ??
        SetD Libre+1, actual        @ED     %Guardo enlace dinamico %main es estatico asi que no tien this!                                    
        SetActual Libre                     %Muevo actual para que apunte al RA que acabo de crear para main
        SetLibre Actual+5                   %Muevo libre segun el tamaño del RA de main (considerando las vars locales)
        Jump Main                           %Salto al codigo de main
        Halt                                %Cuando termino de ejecutar main finalizo

%%%--------------------Traduccion de init de la clase A-------------------------
initA           SetH D[Actual+2]+1,2     @v1=2            %Guardo el valor del parametro p en x  a traves de this en el RA
                SetH D[Actual+2]+2,0  @v2=0         %Guardo el valor del parametro p*5 en y  a traves de this en el RA
                SetLibre Actual                                     %Limpio la memoria del RA de init
                SetActual D[Libre+1]                                %Muevo Actual a donde tenia el enlase dinamico
                Jump D[Libre]                                       %Salto a la direccion de codigo que guarde en el puntero de retorno
%%%-----------------------------------------------------------------------------

%%%----------------------------------CLASE A TRADUCCION-------------------------

%%%--------------------Traduccion de m1 de la clase A-------------------------
m1A             SetD Actual+4,0     @i=0            %Guardo el valor 0 en la variable i
                SetD Actual+5,1  @seguir=true         %Guardo el valor true '1' en la variable seguir
beginWhileM1A   JumpT endWhileM1A,!(D[Actual+5] & D[Actual+4]<D[Actual+3]) @seguir & i < max  %Condicion del while si es verdadera la contra condicion salta al final del while
                JumpT thenM1A, (H[D[Actual+2]+1])+ D[Actual+4] > H[(D[Actual+2]+2)] * D[Actual+4] @ v1 + i > v2 * i     
elseM1A         SetD Actual-1,(H[D[Actual+2]+1])*(H[D[Actual+2]+2]) @return v1*v2
                Jump retM1A
thenM1A         SetH D[Actual+2]+2,H[D[Actual+2]+2]+D[Actual+4] @v2 = v2 + i
                SetH D[Actual+2]+1,H[D[Actual+1]+2]+D[Actual+4] @v1 = v1 + i
                SetD Actual+5,(H[D[Actual+2]+1])!=(H[D[Actual+2]+2]) @seguir = v1 != v2;
                SetD Actual+4,D[Actual+4]+1 @i = i+1;
                Jump beginWhileM1A
endWhileM1A     SetD Actual-1, (H[D[Actual+2]+1])+(H[D[Actual+2]+2])  %return de v1+v2     
retM1A          SetLibre Actual                                     %Limpio la memoria del RA de m1
                SetActual D[Libre+1]                                %Muevo Actual a donde tenia el enlase dinamico
                Jump D[Libre]                                       %Salto a la direccion de codigo que guarde en el puntero de retorno
%%%-----------------------------------------------------------------------------

%--------------------------Traduccion de m2 de la clase A-----------------------------
m2A             SetLibre Libre+1  @Lugar de retorno
                SetD Libre, PC+7 @PR
                SetD Libre+1, Actual   @ED
                SetD Libre+2, D[Actual+2] @this
                SetD Libre+3, (H[D[Actual+2]+1])*3 @param v1*3
                SetActual Libre               %Actualizo Actual par que apunte al RA de m1 nuevo           
                SetLibre Libre+6              %Actalizo el libre con el tamanio del RA de m1
                Jump m1A %salto al codigo m1 de a
                SetD Actual+3,D[Libre-1] @j=m1(v1*3)
                SetD Actual-1, D[Actual+3]
                SetLibre Actual                                     %Limpio la memoria del RA de m2
                SetActual D[Libre+1]                                %Muevo Actual a donde tenia el enlase dinamico
                Jump D[Libre]                                       %Salto a la direccion de codigo que guarde en el puntero de retorno


%%%----------------------------------CLASE C TRADUCCION-------------------------
%--------------------------Traduccion de init de la clase C-----------------------------
initC           SetD Libre, PC+6 @PR
                SetD Libre+1, Actual @ED
                SetD Libre+2, D[Actual+2] @this
                SetActual Libre
                SetLibre Actual+3
                Jump initA
                SetH D[Actual+2]+3, 2
                SetLibre Actual                                     %Limpio la memoria del RA de m2
                SetActual D[Libre+1]                                %Muevo Actual a donde tenia el enlase dinamico
                Jump D[Libre]                                       %Salto a la direccion de codigo que guarde en el puntero de retorno

%--------------------------Traduccion de m1 de la clase C-----------------------------

m1C             JumpT thenM1C,D[Actual+3]>= ((H[D[Actual+2]+1])+(H[D[Actual+2]+2])+(H[D[Actual+2]+3])) | D[Actual+3]==2   @ max >= (v1 + v2 + v3) | max == 2     
elseM1C         SetLibre Libre+1
                SetD Libre, PC+c7 @PR
                SetD Libre+1, Actual @ED
                SetD Libre+2, Actual+2 @this
                SetD Libre+3, D[Actual+3]
                SetActual Libre
                setLibre Actual+6
                Jump m1A
                SetD Actual-1, D[Libre-1] @return super.m1(max);
                Jump retM1C
thenM1C         SetD Actual+3, D[Actual+3]+((H[D[Actual+2]+1])*(H[D[Actual+2]+2])*(H[D[Actual+2]+3])) @max = max + (v1 * v2 * v3);
                SetD Actual-1, D[Actual+3]  @return max;
retM1C          SetLibre Actual                                     %Limpio la memoria del RA de m1
                SetActual D[Libre+1]                                %Muevo Actual a donde tenia el enlase dinamico
                Jump D[Libre]                                       %Salto a la direccion de codigo que guarde en el puntero de retorno
 
 %%%-----------------------------------------------------------------------------               